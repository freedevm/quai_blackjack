"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ERC2612ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC2612InvalidSigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidAccountNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ECDSAInvalidSignature()\":[{\"details\":\"The signature derives the `address(0)`.\"}],\"ECDSAInvalidSignatureLength(uint256)\":[{\"details\":\"The signature has an invalid length.\"}],\"ECDSAInvalidSignatureS(bytes32)\":[{\"details\":\"The signature has an S value that is in the upper half order.\"}],\"ERC2612ExpiredSignature(uint256)\":[{\"details\":\"Permit deadline has expired.\"}],\"ERC2612InvalidSigner(address,address)\":[{\"details\":\"Mismatched signature.\"}],\"InvalidAccountNonce(address,uint256)\":[{\"details\":\"The nonce used for an `account` is not the expected current nonce.\"}]},\"kind\":\"dev\",\"methods\":{\"DOMAIN_SEPARATOR()\":{\"details\":\"Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\"},\"eip712Domain()\":{\"details\":\"See {IERC-5267}.\"},\"nonces(address)\":{\"details\":\"Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times.\"},\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\":{\"details\":\"Sets `value` as the allowance of `spender` over ``owner``'s tokens, given ``owner``'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section]. CAUTION: See Security Considerations above.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ERC20.sol\":\"ERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0xdc6f7c5d0c8e145fd21aa1647db200d8fff2b8065b49177e545f7e6ef6af03b7\",\"license\":\"MIT\"},\"contracts/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    enum RecoverError {\\r\\n        NoError,\\r\\n        InvalidSignature,\\r\\n        InvalidSignatureLength,\\r\\n        InvalidSignatureS\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The signature derives the `address(0)`.\\r\\n     */\\r\\n    error ECDSAInvalidSignature();\\r\\n\\r\\n    /**\\r\\n     * @dev The signature has an invalid length.\\r\\n     */\\r\\n    error ECDSAInvalidSignatureLength(uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev The signature has an S value that is in the upper half order.\\r\\n     */\\r\\n    error ECDSAInvalidSignatureS(bytes32 s);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\r\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\r\\n     * and a bytes32 providing additional information about the error.\\r\\n     *\\r\\n     * If no error is returned, then the address can be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\r\\n     *\\r\\n     * Documentation for signature generation:\\r\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\r\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        bytes memory signature\\r\\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\\r\\n        if (signature.length == 65) {\\r\\n            bytes32 r;\\r\\n            bytes32 s;\\r\\n            uint8 v;\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            assembly (\\\"memory-safe\\\") {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        } else {\\r\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\r\\n     *\\r\\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        bytes32 r,\\r\\n        bytes32 vs\\r\\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\\r\\n        unchecked {\\r\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\r\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\r\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\r\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\r\\n        }\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        if (signer == address(0)) {\\r\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\r\\n        }\\r\\n\\r\\n        return (signer, RecoverError.NoError, bytes32(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\r\\n     */\\r\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\r\\n        if (error == RecoverError.NoError) {\\r\\n            return; // no error: do nothing\\r\\n        } else if (error == RecoverError.InvalidSignature) {\\r\\n            revert ECDSAInvalidSignature();\\r\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\r\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\r\\n        } else if (error == RecoverError.InvalidSignatureS) {\\r\\n            revert ECDSAInvalidSignatureS(errorArg);\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x3ba64381b3abdb4a23b9bc9db7002192d8725850f9f6a053e5fa9d4314c8b94e\",\"license\":\"MIT\"},\"contracts/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/EIP712.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {MessageHashUtils} from \\\"./MessageHashUtils.sol\\\";\\r\\nimport {ShortStrings, ShortString} from \\\"./ShortStrings.sol\\\";\\r\\nimport {IERC5267} from \\\"./IERC5267.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\\r\\n *\\r\\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\\r\\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\\r\\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\\r\\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\\r\\n *\\r\\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\r\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\r\\n * ({_hashTypedDataV4}).\\r\\n *\\r\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\r\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\r\\n *\\r\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\r\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\r\\n *\\r\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\r\\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\\r\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\r\\n *\\r\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n */\\r\\nabstract contract EIP712 is IERC5267 {\\r\\n    using ShortStrings for *;\\r\\n\\r\\n    bytes32 private constant TYPE_HASH =\\r\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\r\\n    // invalidate the cached domain separator if the chain id changes.\\r\\n    bytes32 private immutable _cachedDomainSeparator;\\r\\n    uint256 private immutable _cachedChainId;\\r\\n    address private immutable _cachedThis;\\r\\n\\r\\n    bytes32 private immutable _hashedName;\\r\\n    bytes32 private immutable _hashedVersion;\\r\\n\\r\\n    ShortString private immutable _name;\\r\\n    ShortString private immutable _version;\\r\\n    string private _nameFallback;\\r\\n    string private _versionFallback;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the domain separator and parameter caches.\\r\\n     *\\r\\n     * The meaning of `name` and `version` is specified in\\r\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\\r\\n     *\\r\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\r\\n     * - `version`: the current major version of the signing domain.\\r\\n     *\\r\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\r\\n     * contract upgrade].\\r\\n     */\\r\\n    constructor(string memory name, string memory version) {\\r\\n        _name = name.toShortStringWithFallback(_nameFallback);\\r\\n        _version = version.toShortStringWithFallback(_versionFallback);\\r\\n        _hashedName = keccak256(bytes(name));\\r\\n        _hashedVersion = keccak256(bytes(version));\\r\\n\\r\\n        _cachedChainId = block.chainid;\\r\\n        _cachedDomainSeparator = _buildDomainSeparator();\\r\\n        _cachedThis = address(this);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator for the current chain.\\r\\n     */\\r\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\r\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\r\\n            return _cachedDomainSeparator;\\r\\n        } else {\\r\\n            return _buildDomainSeparator();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buildDomainSeparator() private view returns (bytes32) {\\r\\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\r\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\r\\n     *\\r\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\r\\n     *\\r\\n     * ```solidity\\r\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\r\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\r\\n     *     mailTo,\\r\\n     *     keccak256(bytes(mailContents))\\r\\n     * )));\\r\\n     * address signer = ECDSA.recover(digest, signature);\\r\\n     * ```\\r\\n     */\\r\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\r\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC-5267}.\\r\\n     */\\r\\n    function eip712Domain()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (\\r\\n            bytes1 fields,\\r\\n            string memory name,\\r\\n            string memory version,\\r\\n            uint256 chainId,\\r\\n            address verifyingContract,\\r\\n            bytes32 salt,\\r\\n            uint256[] memory extensions\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            hex\\\"0f\\\", // 01111\\r\\n            _EIP712Name(),\\r\\n            _EIP712Version(),\\r\\n            block.chainid,\\r\\n            address(this),\\r\\n            bytes32(0),\\r\\n            new uint256[](0)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The name parameter for the EIP712 domain.\\r\\n     *\\r\\n     * NOTE: By default this function reads _name which is an immutable value.\\r\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function _EIP712Name() internal view returns (string memory) {\\r\\n        return _name.toStringWithFallback(_nameFallback);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The version parameter for the EIP712 domain.\\r\\n     *\\r\\n     * NOTE: By default this function reads _version which is an immutable value.\\r\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function _EIP712Version() internal view returns (string memory) {\\r\\n        return _version.toStringWithFallback(_versionFallback);\\r\\n    }\\r\\n}\",\"keccak256\":\"0xeb35f2f9b63573584419e231bb9da189392766e3f98e7af862b5e481363324d1\",\"license\":\"MIT\"},\"contracts/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC20Metadata.sol\\\";\\r\\nimport \\\"./EIP712.sol\\\";\\r\\nimport \\\"./Nonces.sol\\\";\\r\\nimport \\\"./IERC20Permit.sol\\\";\\r\\nimport \\\"./ECDSA.sol\\\";\\r\\n\\r\\ncontract ERC20 is IERC20, IERC20Metadata, IERC20Permit, EIP712, Nonces {\\r\\n    using Address for address;\\r\\n\\r\\n    bytes32 private constant PERMIT_TYPEHASH =\\r\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n\\r\\n    /**\\r\\n     * @dev Permit deadline has expired.\\r\\n     */\\r\\n    error ERC2612ExpiredSignature(uint256 deadline);\\r\\n\\r\\n    /**\\r\\n     * @dev Mismatched signature.\\r\\n     */\\r\\n    error ERC2612InvalidSigner(address signer, address owner);\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint256 totalSupply_\\r\\n    ) EIP712(name_, \\\"1\\\") {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _mint(msg.sender, totalSupply_);\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(\\r\\n        address account\\r\\n    ) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\r\\n        require(\\r\\n            currentAllowance >= amount,\\r\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint256 subtractedValue\\r\\n    ) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[msg.sender][spender];\\r\\n        require(\\r\\n            currentAllowance >= subtractedValue,\\r\\n            \\\"ERC20: decreased allowance below zero\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint256 addedValue\\r\\n    ) public virtual returns (bool) {\\r\\n        _approve(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowances[msg.sender][spender] + addedValue\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(\\r\\n            senderBalance >= amount,\\r\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _balances[sender] = senderBalance - amount;\\r\\n        }\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IERC20Permit\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        if (block.timestamp > deadline) {\\r\\n            revert ERC2612ExpiredSignature(deadline);\\r\\n        }\\r\\n\\r\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\r\\n\\r\\n        bytes32 hash = _hashTypedDataV4(structHash);\\r\\n\\r\\n        address signer = ECDSA.recover(hash, v, r, s);\\r\\n        if (signer != owner) {\\r\\n            revert ERC2612InvalidSigner(signer, owner);\\r\\n        }\\r\\n\\r\\n        _approve(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IERC20Permit\\r\\n     */\\r\\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\\r\\n        return super.nonces(owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IERC20Permit\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\\r\\n        return _domainSeparatorV4();\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2ef42dcc23ac09b9080f06f22a2128017f4257951b9444c4690e2c6d7fc69233\",\"license\":\"MIT\"},\"contracts/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\",\"keccak256\":\"0xf1c6b3772a4f2ef609b691567d287ca660cfaf3c08098db2fab688161527d1cb\",\"license\":\"MIT\"},\"contracts/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\",\"keccak256\":\"0x0058a9166490cd86c4a925e9eae26ba8b466c9e3f541ec8a9fbccf61d39a1b01\",\"license\":\"MIT\"},\"contracts/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n *\\r\\n * ==== Security Considerations\\r\\n *\\r\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\r\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\r\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\r\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\r\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\r\\n * generally recommended is:\\r\\n *\\r\\n * ```solidity\\r\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\r\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\r\\n *     doThing(..., value);\\r\\n * }\\r\\n *\\r\\n * function doThing(..., uint256 value) public {\\r\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\r\\n *     ...\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\r\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\r\\n * {SafeERC20-safeTransferFrom}).\\r\\n *\\r\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\r\\n * contracts should have entry points that don't rely on permit.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     *\\r\\n     * CAUTION: See Security Considerations above.\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\",\"keccak256\":\"0x909189190215940f2461390cb2795d420e4562e50944723b285ca21b7d9013d8\",\"license\":\"MIT\"},\"contracts/IERC5267.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IERC5267 {\\r\\n    /**\\r\\n     * @dev MAY be emitted to signal that the domain could have changed.\\r\\n     */\\r\\n    event EIP712DomainChanged();\\r\\n\\r\\n    /**\\r\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\r\\n     * signature.\\r\\n     */\\r\\n    function eip712Domain()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            bytes1 fields,\\r\\n            string memory name,\\r\\n            string memory version,\\r\\n            uint256 chainId,\\r\\n            address verifyingContract,\\r\\n            bytes32 salt,\\r\\n            uint256[] memory extensions\\r\\n        );\\r\\n}\",\"keccak256\":\"0x876223edf7464250bf20a50724b2a732c33dd3ec84942c55e509786e3682d44d\",\"license\":\"MIT\"},\"contracts/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Muldiv operation overflow.\\r\\n     */\\r\\n    error MathOverflowedMulDiv();\\r\\n\\r\\n    enum Rounding {\\r\\n        Floor, // Toward negative infinity\\r\\n        Ceil, // Toward positive infinity\\r\\n        Trunc, // Toward zero\\r\\n        Expand // Away from zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\r\\n     * of rounding towards zero.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (b == 0) {\\r\\n            // Guarantee the same behavior as in a regular Solidity division.\\r\\n            return a / b;\\r\\n        }\\r\\n\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\r\\n     * denominator == 0.\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\r\\n     * Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\r\\n                // The surrounding unchecked block does not change this fact.\\r\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            if (denominator <= prod1) {\\r\\n                revert MathOverflowedMulDiv();\\r\\n            }\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\r\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            uint256 twos = denominator & (0 - denominator);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\r\\n            // works in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\r\\n     * towards zero.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\r\\n     */\\r\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\r\\n        return uint8(rounding) % 2 == 1;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x261822f7c729b791c53b2a67cdfb3e0d99168503824e451a3752009edad39f0d\",\"license\":\"MIT\"},\"contracts/MessageHashUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MessageHashUtils.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {Strings} from \\\"./Strings.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\r\\n *\\r\\n * The library provides methods for generating a hash of a message that conforms to the\\r\\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\r\\n * specifications.\\r\\n */\\r\\nlibrary MessageHashUtils {\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\\r\\n     * `0x45` (`personal_sign` messages).\\r\\n     *\\r\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\r\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\r\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\r\\n     *\\r\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\r\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\r\\n     * be re-hashed.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\r\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\r\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\\r\\n     * `0x45` (`personal_sign` messages).\\r\\n     *\\r\\n     * The digest is calculated by prefixing an arbitrary `message` with\\r\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\r\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\\r\\n     * `0x00` (data with intended validator).\\r\\n     *\\r\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\r\\n     * `validator` address. Then hashing the result.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\\r\\n     *\\r\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\r\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\r\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\r\\n     *\\r\\n     * See {ECDSA-recover}.\\r\\n     */\\r\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            let ptr := mload(0x40)\\r\\n            mstore(ptr, hex\\\"19_01\\\")\\r\\n            mstore(add(ptr, 0x02), domainSeparator)\\r\\n            mstore(add(ptr, 0x22), structHash)\\r\\n            digest := keccak256(ptr, 0x42)\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x7b9ca38fb1b624a655cf5c87404a11ba3d55553887a6308c77c36f344010e3e9\",\"license\":\"MIT\"},\"contracts/Nonces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\\r\\n */\\r\\nabstract contract Nonces {\\r\\n    /**\\r\\n     * @dev The nonce used for an `account` is not the expected current nonce.\\r\\n     */\\r\\n    error InvalidAccountNonce(address account, uint256 currentNonce);\\r\\n\\r\\n    mapping(address => uint256) private _nonces;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the next unused nonce for an address.\\r\\n     */\\r\\n    function nonces(address owner) public view virtual returns (uint256) {\\r\\n        return _nonces[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Consumes a nonce.\\r\\n     *\\r\\n     * Returns the current value and increments nonce.\\r\\n     */\\r\\n    function _useNonce(address owner) internal virtual returns (uint256) {\\r\\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\\r\\n        // decremented or reset. This guarantees that the nonce never overflows.\\r\\n        unchecked {\\r\\n            // It is important to do x++ and not ++x here.\\r\\n            return _nonces[owner]++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\\r\\n     */\\r\\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\\r\\n        uint256 current = _useNonce(owner);\\r\\n        if (nonce != current) {\\r\\n            revert InvalidAccountNonce(owner, current);\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x761f552efdccf5856fc0ee3d8b8319b246e7f97d7d05ac71c20571212ce8027c\",\"license\":\"MIT\"},\"contracts/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntToUint(int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintToInt(uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        if (value > type(uint248).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(248, value);\\r\\n        }\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        if (value > type(uint240).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(240, value);\\r\\n        }\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        if (value > type(uint232).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(232, value);\\r\\n        }\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        if (value > type(uint224).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(224, value);\\r\\n        }\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        if (value > type(uint216).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(216, value);\\r\\n        }\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        if (value > type(uint208).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(208, value);\\r\\n        }\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        if (value > type(uint200).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(200, value);\\r\\n        }\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        if (value > type(uint192).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(192, value);\\r\\n        }\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        if (value > type(uint184).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(184, value);\\r\\n        }\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        if (value > type(uint176).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(176, value);\\r\\n        }\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        if (value > type(uint168).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(168, value);\\r\\n        }\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        if (value > type(uint160).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(160, value);\\r\\n        }\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        if (value > type(uint152).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(152, value);\\r\\n        }\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        if (value > type(uint144).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(144, value);\\r\\n        }\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        if (value > type(uint136).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(136, value);\\r\\n        }\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        if (value > type(uint128).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(128, value);\\r\\n        }\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        if (value > type(uint120).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(120, value);\\r\\n        }\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        if (value > type(uint112).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(112, value);\\r\\n        }\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        if (value > type(uint104).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(104, value);\\r\\n        }\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        if (value > type(uint96).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(96, value);\\r\\n        }\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        if (value > type(uint88).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(88, value);\\r\\n        }\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        if (value > type(uint80).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(80, value);\\r\\n        }\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        if (value > type(uint72).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(72, value);\\r\\n        }\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        if (value > type(uint64).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(64, value);\\r\\n        }\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        if (value > type(uint56).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(56, value);\\r\\n        }\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        if (value > type(uint48).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(48, value);\\r\\n        }\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        if (value > type(uint40).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(40, value);\\r\\n        }\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        if (value > type(uint32).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(32, value);\\r\\n        }\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        if (value > type(uint24).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(24, value);\\r\\n        }\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        if (value > type(uint16).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(16, value);\\r\\n        }\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        if (value > type(uint8).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(8, value);\\r\\n        }\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        if (value < 0) {\\r\\n            revert SafeCastOverflowedIntToUint(value);\\r\\n        }\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(248, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(240, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(232, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(224, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(216, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(208, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(200, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(192, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(184, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(176, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(168, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(160, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(152, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(144, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(136, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(128, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(120, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(112, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(104, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(96, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(88, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(80, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(72, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(64, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(56, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(48, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(40, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(32, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(24, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(16, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(8, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        if (value > uint256(type(int256).max)) {\\r\\n            revert SafeCastOverflowedUintToInt(value);\\r\\n        }\\r\\n        return int256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\r\\n     */\\r\\n    function toUint(bool b) internal pure returns (uint256 u) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            u := iszero(iszero(b))\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x961a6a8aa2b6fef7d623252db5edca2d69cbc32192240805d5c2ab1e0f6344b1\",\"license\":\"MIT\"},\"contracts/ShortStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ShortStrings.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\r\\n\\r\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\r\\n// | length  | 0x                                                              BB |\\r\\ntype ShortString is bytes32;\\r\\n\\r\\n/**\\r\\n * @dev This library provides functions to convert short memory strings\\r\\n * into a `ShortString` type that can be used as an immutable variable.\\r\\n *\\r\\n * Strings of arbitrary length can be optimized using this library if\\r\\n * they are short enough (up to 31 bytes) by packing them with their\\r\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\r\\n * fallback mechanism can be used for every other case.\\r\\n *\\r\\n * Usage example:\\r\\n *\\r\\n * ```solidity\\r\\n * contract Named {\\r\\n *     using ShortStrings for *;\\r\\n *\\r\\n *     ShortString private immutable _name;\\r\\n *     string private _nameFallback;\\r\\n *\\r\\n *     constructor(string memory contractName) {\\r\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\r\\n *     }\\r\\n *\\r\\n *     function name() external view returns (string memory) {\\r\\n *         return _name.toStringWithFallback(_nameFallback);\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n */\\r\\nlibrary ShortStrings {\\r\\n    // Used as an identifier for strings longer than 31 bytes.\\r\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\r\\n\\r\\n    error StringTooLong(string str);\\r\\n    error InvalidShortString();\\r\\n\\r\\n    /**\\r\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\r\\n     *\\r\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\r\\n     */\\r\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\r\\n        bytes memory bstr = bytes(str);\\r\\n        if (bstr.length > 31) {\\r\\n            revert StringTooLong(str);\\r\\n        }\\r\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\r\\n     */\\r\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\r\\n        uint256 len = byteLength(sstr);\\r\\n        // using `new string(len)` would work locally but is not memory safe.\\r\\n        string memory str = new string(32);\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            mstore(str, len)\\r\\n            mstore(add(str, 0x20), sstr)\\r\\n        }\\r\\n        return str;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the length of a `ShortString`.\\r\\n     */\\r\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\r\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\r\\n        if (result > 31) {\\r\\n            revert InvalidShortString();\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\r\\n     */\\r\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\r\\n        if (bytes(value).length < 32) {\\r\\n            return toShortString(value);\\r\\n        } else {\\r\\n            StorageSlot.getStringSlot(store).value = value;\\r\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\r\\n     */\\r\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\r\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\r\\n            return toString(value);\\r\\n        } else {\\r\\n            return store;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\r\\n     * {setWithFallback}.\\r\\n     *\\r\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\r\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\r\\n     */\\r\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\r\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\r\\n            return byteLength(value);\\r\\n        } else {\\r\\n            return bytes(store).length;\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x100b22b7cf45a6da890e082b8d10211711bd1c7fbc2acdd9701c155ecfb9815d\",\"license\":\"MIT\"},\"contracts/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Standard signed math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary SignedMath {\\r\\n    /**\\r\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\r\\n     *\\r\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\r\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\r\\n     * one branch when needed, making this function more expensive.\\r\\n     */\\r\\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            // branchless ternary works because:\\r\\n            // b ^ (a ^ b) == a\\r\\n            // b ^ 0 == b\\r\\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two signed numbers.\\r\\n     */\\r\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return ternary(a > b, a, b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two signed numbers.\\r\\n     */\\r\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return ternary(a < b, a, b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two signed numbers without overflow.\\r\\n     * The result is rounded towards zero.\\r\\n     */\\r\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Formula from the book \\\"Hacker's Delight\\\"\\r\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\r\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the absolute unsigned value of a signed value.\\r\\n     */\\r\\n    function abs(int256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // Formula from the \\\"Bit Twiddling Hacks\\\" by Sean Eron Anderson.\\r\\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\\r\\n            // taking advantage of the most significant (or \\\"sign\\\" bit) in two's complement representation.\\r\\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\\r\\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\\r\\n            int256 mask = n >> 255;\\r\\n\\r\\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\\r\\n            return uint256((n + mask) ^ mask);\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x0cbccda1e8f10a7217a92a04970cc83fe09795ad78586917c8a5d932c8d12501\",\"license\":\"MIT\"},\"contracts/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Library for reading and writing primitive types to specific storage slots.\\r\\n *\\r\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\r\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\r\\n *\\r\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\r\\n *\\r\\n * Example usage to set ERC-1967 implementation slot:\\r\\n * ```solidity\\r\\n * contract ERC1967 {\\r\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\r\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n *\\r\\n *     function _getImplementation() internal view returns (address) {\\r\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n *     }\\r\\n *\\r\\n *     function _setImplementation(address newImplementation) internal {\\r\\n *         require(newImplementation.code.length > 0);\\r\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * TIP: Consider using this library along with {SlotDerivation}.\\r\\n */\\r\\nlibrary StorageSlot {\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    struct BooleanSlot {\\r\\n        bool value;\\r\\n    }\\r\\n\\r\\n    struct Bytes32Slot {\\r\\n        bytes32 value;\\r\\n    }\\r\\n\\r\\n    struct Uint256Slot {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    struct Int256Slot {\\r\\n        int256 value;\\r\\n    }\\r\\n\\r\\n    struct StringSlot {\\r\\n        string value;\\r\\n    }\\r\\n\\r\\n    struct BytesSlot {\\r\\n        bytes value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\r\\n     */\\r\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := store.slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\r\\n     */\\r\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            r.slot := store.slot\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x85be17dae57122cd5d8658fff9ffa8ef7bf6271cd3d416dd1a9dca13532f1fd0\",\"license\":\"MIT\"},\"contracts/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Strings.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport {Math} from \\\"./Math.sol\\\";\\r\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\r\\nimport {SignedMath} from \\\"./SignedMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    using SafeCast for *;\\r\\n\\r\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev The `value` string doesn't fit in the specified `length`.\\r\\n     */\\r\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev The string being parsed contains characters that are not in scope of the given base.\\r\\n     */\\r\\n    error StringsInvalidChar();\\r\\n\\r\\n    /**\\r\\n     * @dev The string being parsed is not a properly formatted address.\\r\\n     */\\r\\n    error StringsInvalidAddressFormat();\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            assembly (\\\"memory-safe\\\") {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                assembly (\\\"memory-safe\\\") {\\r\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\r\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        uint256 localValue = value;\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\r\\n            localValue >>= 4;\\r\\n        }\\r\\n        if (localValue != 0) {\\r\\n            revert StringsInsufficientHexLength(value, length);\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\r\\n     * representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\\r\\n     * representation, according to EIP-55.\\r\\n     */\\r\\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\\r\\n        bytes memory buffer = bytes(toHexString(addr));\\r\\n\\r\\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\\r\\n        uint256 hashValue;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 41; i > 1; --i) {\\r\\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\\r\\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\\r\\n                // case shift by xoring with 0x20\\r\\n                buffer[i] ^= 0x20;\\r\\n            }\\r\\n            hashValue >>= 4;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the two strings are equal.\\r\\n     */\\r\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\r\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Parse a decimal string and returns the value as a `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The string must be formatted as `[0-9]*`\\r\\n     * - The result must fit into an `uint256` type\\r\\n     */\\r\\n    function parseUint(string memory input) internal pure returns (uint256) {\\r\\n        return parseUint(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseUint} that parses a substring of `input` located between position `begin` (included) and\\r\\n     * `end` (excluded).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The substring must be formatted as `[0-9]*`\\r\\n     * - The result must fit into an `uint256` type\\r\\n     */\\r\\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\\r\\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\\r\\n        if (!success) revert StringsInvalidChar();\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\\r\\n     *\\r\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\r\\n     */\\r\\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\\r\\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\\r\\n     * character.\\r\\n     *\\r\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\r\\n     */\\r\\n    function tryParseUint(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) internal pure returns (bool success, uint256 value) {\\r\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\r\\n        return _tryParseUintUncheckedBounds(input, begin, end);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {tryParseUint} that does not check bounds and returns (true, 0) if they are invalid.\\r\\n     */\\r\\n    function _tryParseUintUncheckedBounds(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) private pure returns (bool success, uint256 value) {\\r\\n        bytes memory buffer = bytes(input);\\r\\n\\r\\n        uint256 result = 0;\\r\\n        for (uint256 i = begin; i < end; ++i) {\\r\\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\\r\\n            if (chr > 9) return (false, 0);\\r\\n            result *= 10;\\r\\n            result += chr;\\r\\n        }\\r\\n        return (true, result);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Parse a decimal string and returns the value as a `int256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The string must be formatted as `[-+]?[0-9]*`\\r\\n     * - The result must fit in an `int256` type.\\r\\n     */\\r\\n    function parseInt(string memory input) internal pure returns (int256) {\\r\\n        return parseInt(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\\r\\n     * `end` (excluded).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The substring must be formatted as `[-+]?[0-9]*`\\r\\n     * - The result must fit in an `int256` type.\\r\\n     */\\r\\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\\r\\n        (bool success, int256 value) = tryParseInt(input, begin, end);\\r\\n        if (!success) revert StringsInvalidChar();\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\\r\\n     * the result does not fit in a `int256`.\\r\\n     *\\r\\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\\r\\n     */\\r\\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\\r\\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\\r\\n     * character or if the result does not fit in a `int256`.\\r\\n     *\\r\\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\\r\\n     */\\r\\n    function tryParseInt(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) internal pure returns (bool success, int256 value) {\\r\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\r\\n        return _tryParseIntUncheckedBounds(input, begin, end);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {tryParseInt} that does not check bounds and returns (true, 0) if they are invalid.\\r\\n     */\\r\\n    function _tryParseIntUncheckedBounds(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) private pure returns (bool success, int256 value) {\\r\\n        bytes memory buffer = bytes(input);\\r\\n\\r\\n        // Check presence of a negative sign.\\r\\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\r\\n        bool positiveSign = sign == bytes1(\\\"+\\\");\\r\\n        bool negativeSign = sign == bytes1(\\\"-\\\");\\r\\n        uint256 offset = (positiveSign || negativeSign).toUint();\\r\\n\\r\\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\\r\\n\\r\\n        if (absSuccess && absValue < ABS_MIN_INT256) {\\r\\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\\r\\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\\r\\n            return (true, type(int256).min);\\r\\n        } else return (false, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Parse a hexadecimal string (with or without \\\"0x\\\" prefix), and returns the value as a `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\\r\\n     * - The result must fit in an `uint256` type.\\r\\n     */\\r\\n    function parseHexUint(string memory input) internal pure returns (uint256) {\\r\\n        return parseHexUint(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseHexUint} that parses a substring of `input` located between position `begin` (included) and\\r\\n     * `end` (excluded).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\\r\\n     * - The result must fit in an `uint256` type.\\r\\n     */\\r\\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\\r\\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\\r\\n        if (!success) revert StringsInvalidChar();\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\\r\\n     *\\r\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\r\\n     */\\r\\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\\r\\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\\r\\n     * invalid character.\\r\\n     *\\r\\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\\r\\n     */\\r\\n    function tryParseHexUint(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) internal pure returns (bool success, uint256 value) {\\r\\n        if (end > bytes(input).length || begin > end) return (false, 0);\\r\\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {tryParseHexUint} that does not check bounds and returns (true, 0) if they are invalid.\\r\\n     */\\r\\n    function _tryParseHexUintUncheckedBounds(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) private pure returns (bool success, uint256 value) {\\r\\n        bytes memory buffer = bytes(input);\\r\\n\\r\\n        // skip 0x prefix if present\\r\\n        bool hasPrefix = (begin < end + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\\\"0x\\\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\r\\n        uint256 offset = hasPrefix.toUint() * 2;\\r\\n\\r\\n        uint256 result = 0;\\r\\n        for (uint256 i = begin + offset; i < end; ++i) {\\r\\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\\r\\n            if (chr > 15) return (false, 0);\\r\\n            result *= 16;\\r\\n            unchecked {\\r\\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\\r\\n                // This guaratees that adding a value < 16 will not cause an overflow, hence the unchecked.\\r\\n                result += chr;\\r\\n            }\\r\\n        }\\r\\n        return (true, result);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Parse a hexadecimal string (with or without \\\"0x\\\" prefix), and returns the value as an `address`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\\r\\n     */\\r\\n    function parseAddress(string memory input) internal pure returns (address) {\\r\\n        return parseAddress(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseAddress} that parses a substring of `input` located between position `begin` (included) and\\r\\n     * `end` (excluded).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\\r\\n     */\\r\\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\\r\\n        (bool success, address value) = tryParseAddress(input, begin, end);\\r\\n        if (!success) revert StringsInvalidAddressFormat();\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\\r\\n     * formatted address. See {parseAddress} requirements.\\r\\n     */\\r\\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\\r\\n        return tryParseAddress(input, 0, bytes(input).length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\\r\\n     * formatted address. See {parseAddress} requirements.\\r\\n     */\\r\\n    function tryParseAddress(\\r\\n        string memory input,\\r\\n        uint256 begin,\\r\\n        uint256 end\\r\\n    ) internal pure returns (bool success, address value) {\\r\\n        // check that input is the correct length\\r\\n        bool hasPrefix = (begin < end + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\\\"0x\\\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\\r\\n\\r\\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\\r\\n\\r\\n        if (end - begin == expectedLength && end <= bytes(input).length) {\\r\\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\\r\\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\\r\\n            return (s, address(uint160(v)));\\r\\n        } else {\\r\\n            return (false, address(0));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\\r\\n        uint8 value = uint8(chr);\\r\\n\\r\\n        // Try to parse `chr`:\\r\\n        // - Case 1: [0-9]\\r\\n        // - Case 2: [a-f]\\r\\n        // - Case 3: [A-F]\\r\\n        // - otherwise not supported\\r\\n        unchecked {\\r\\n            if (value > 47 && value < 58) value -= 48;\\r\\n            else if (value > 96 && value < 103) value -= 87;\\r\\n            else if (value > 64 && value < 71) value -= 55;\\r\\n            else return type(uint8).max;\\r\\n        }\\r\\n\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\\r\\n     *\\r\\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\\r\\n     * assembly block as such would prevent some optimizations.\\r\\n     */\\r\\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\\r\\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            value := mload(add(buffer, add(0x20, offset)))\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0xce5ca113d4cd3005cbf2109590734a0410a5eebc6fc94d258af1897a40c29341\",\"license\":\"MIT\"}},\"version\":1}"